(** E618: Avoid X__Y Module Access - Use X.Y Instead *)

type payload = { module_path : string; suggested_path : string }

let check (ctx : Context.file) =
  let dump_data = Context.dump ctx in
  let filename = ctx.filename in

  (* Check identifiers for double underscore module access patterns *)
  let issues = ref [] in

  (* OCaml special identifiers that use double underscores *)
  let special_identifiers =
    [
      "__LOC__";
      "__FILE__";
      "__LINE__";
      "__MODULE__";
      "__POS__";
      "__POS_OF__";
      "__LINE_OF__";
      "__MODULE_OF__";
      "__LOC_OF__";
      "__FUNCTION__";
    ]
  in

  (* Helper to check if identifier is a special OCaml identifier *)
  let is_special_identifier name =
    (* Check if the name itself or any part after '.' is a special identifier *)
    let parts = String.split_on_char '.' name in
    List.exists (fun part -> List.mem part special_identifiers) parts
  in

  List.iter
    (fun (elt : Dump.elt) ->
      (* Look for patterns like Module__Submodule *)
      let name = Dump.name_to_string elt.Dump.name in
      if String.contains name '_' then
        (* Skip autogenerated Dune__exe prefixes and OCaml special identifiers *)
        if
          (not (String.starts_with ~prefix:"Dune__exe" name))
          && not (is_special_identifier name)
        then
          (* Look for double underscore NOT followed by a dot - this is the bad pattern *)
          (* Pattern: __ followed by a letter/digit (not a dot) *)
          let bad_pattern =
            Re.compile
              (Re.seq [ Re.str "__"; Re.alt [ Re.alnum; Re.char '_' ] ])
          in
          if Re.execp bad_pattern name then
            (* For the suggestion, remove the library prefix to make it cleaner *)
            let clean_original =
              if String.contains name '.' then
                (* Extract just the problematic part after the library prefix *)
                let parts = String.split_on_char '.' name in
                match parts with
                | _lib :: rest -> String.concat "." rest
                | _ -> name
              else name
            in
            let clean_suggested =
              Re.replace_string
                (Re.compile (Re.str "__"))
                ~by:"." clean_original
            in
            match Dump.location elt with
            | Some loc ->
                (* Ensure the location includes the correct filename *)
                let loc_with_file =
                  Location.v ~file:filename ~start_line:loc.start_line
                    ~start_col:loc.start_col ~end_line:loc.end_line
                    ~end_col:loc.end_col
                in
                issues :=
                  Issue.v ~loc:loc_with_file
                    {
                      module_path = clean_original;
                      suggested_path = clean_suggested;
                    }
                  :: !issues
            | None -> ())
    dump_data.identifiers;

  !issues

let pp ppf { module_path; suggested_path } =
  Fmt.pf ppf "Use '%s' instead of '%s' - avoid double underscore module access"
    suggested_path module_path

let rule =
  Rule.v ~code:"E618" ~title:"Avoid X__Y Module Access"
    ~category:Style_modernization
    ~hint:
      "Avoid using double underscore module access like 'Module__Submodule'. \
       Use dot notation 'Module.Submodule' instead. Double underscore notation \
       is internal to the OCaml module system and should not be used in \
       application code."
    ~examples:
      [
        {
          is_good = false;
          code =
            {|let result = Merlint__Location.v ~file:"test.ml" 
                   ~start_line:1 ~start_col:0 ~end_line:1 ~end_col:10|};
        };
        {
          is_good = true;
          code =
            {|let result = Merlint.Location.v ~file:"test.ml" 
                   ~start_line:1 ~start_col:0 ~end_line:1 ~end_col:10|};
        };
      ]
    ~pp (File check)
